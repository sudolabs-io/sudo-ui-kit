{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "dnd-tree",
  "type": "registry:ui",
  "description": "A drag and drop tree component with support for nested items",
  "dependencies": [
    "@dnd-kit/core@^6.3.1",
    "react-hook-form@7.54.2",
    "zod@3.24.2",
    "lodash@4.17.21",
    "lucide-react@0.477.0",
    "@hookform/resolvers@4.1.3"
  ],
  "registryDependencies": [
    "https://sudolabs-io.github.io/sudo-ui-kit/public/r/utils.json",
    "https://sudolabs-io.github.io/sudo-ui-kit/public/r/button.json",
    "https://sudolabs-io.github.io/sudo-ui-kit/public/r/dialog.json",
    "https://sudolabs-io.github.io/sudo-ui-kit/public/r/form.json",
    "https://sudolabs-io.github.io/sudo-ui-kit/public/r/input.json",
    "https://sudolabs-io.github.io/sudo-ui-kit/public/r/DNDTreeContext.json",
    "https://sudolabs-io.github.io/sudo-ui-kit/public/r/useDNDTree.json",
    "https://sudolabs-io.github.io/sudo-ui-kit/public/r/constants.json"
  ],
  "files": [
    {
      "path": "src/components/ui/dnd/dnd-tree.tsx",
      "content": "import { useId, useState } from 'react'\nimport { DndContext, DragEndEvent } from '@dnd-kit/core'\nimport { TreeItem } from 'context/DNDTreeContext'\nimport { useDNDTree } from 'hooks/useDNDTree'\nimport { isUndefined } from 'lodash'\nimport { DraggableOverlay } from './dnd-drag-and-drop'\nimport { DNDTreeItems } from './dnd-tree-items'\nimport { moveItem } from './utils/dnd'\nimport { updateItems } from './utils/dnd-tree'\n\nexport const DNDTree = () => {\n  const id = useId()\n  const [draggedItem, setDraggedItem] = useState<TreeItem | null>(null)\n  const { treeItems, setTreeItems } = useDNDTree()\n\n  const handleDragEnd = ({ active, over }: DragEndEvent) => {\n    const overId = over?.id as string | null\n    const activeItemId = active.id as string\n\n    if (overId) {\n      const { parentId, beforeId } = moveItem({\n        dropzoneId: overId,\n        items: treeItems,\n        onMove: setTreeItems,\n        id: activeItemId,\n      })\n\n      if (parentId && !isUndefined(beforeId)) {\n        const updatedItems = updateItems({\n          beforeId,\n          parentId,\n          itemId: activeItemId,\n          items: treeItems,\n        })\n        setTreeItems(updatedItems)\n      }\n    }\n    setDraggedItem(null)\n  }\n\n  const handleDragStart = ({ active }: DragEndEvent) => {\n    setTimeout(() =>\n      setDraggedItem({\n        id: active.id as string,\n        name: active.data.current?.name,\n      } as TreeItem),\n    )\n  }\n\n  return (\n    <DndContext id={id} onDragEnd={handleDragEnd} onDragStart={handleDragStart}>\n      <DNDTreeItems draggedItemId={draggedItem?.id} />\n      {draggedItem && <DraggableOverlay name={draggedItem.name} />}\n    </DndContext>\n  )\n}\n",
      "type": "registry:ui",
      "target": "components/ui/dnd/dnd-tree.tsx"
    },
    {
      "path": "src/components/ui/dnd/dnd-tree.stories.tsx",
      "content": "import { useMemo, useState } from 'react'\nimport { Meta, StoryObj } from '@storybook/react'\nimport { DNDTreeContext, DNDTreeContextProps, TreeItem } from 'context/DNDTreeContext'\nimport { DNDTree } from './dnd-tree'\n\nconst MockItems = [\n  { id: '1', name: 'Item 1' },\n  {\n    id: '2',\n    name: 'Item 2',\n    children: [\n      { id: '2.1', name: 'Item 2.1' },\n      { id: '2.2', name: 'Item 2.2' },\n    ],\n  },\n  { id: '3', name: 'Item 3' },\n  {\n    id: '4',\n    name: 'Item 4',\n    children: [\n      { id: '4.1', name: 'Item 4.1' },\n      { id: '4.2', name: 'Item 4.2' },\n    ],\n  },\n  { id: '5', name: 'Item 5' },\n  {\n    id: '6',\n    name: 'Item 6',\n    children: [\n      { id: '6.1', name: 'Item 6.1' },\n      { id: '6.2', name: 'Item 6.2' },\n    ],\n  },\n  { id: '7', name: 'Item 7' },\n  {\n    id: '8',\n    name: 'Item 8',\n    children: [\n      { id: '8.1', name: 'Item 8.1' },\n      { id: '8.2', name: 'Item 8.2' },\n    ],\n  },\n  { id: '9', name: 'Item 9' },\n  { id: '10', name: 'Item 10' },\n]\n\nconst DNDTreeStory = () => {\n  const [treeItems, setTreeItems] = useState<TreeItem[]>(MockItems)\n\n  const contextValue = useMemo<DNDTreeContextProps>(\n    () => ({ treeItems, setTreeItems }),\n    [treeItems, setTreeItems],\n  )\n\n  return (\n    <DNDTreeContext.Provider value={contextValue}>\n      <DNDTree />\n    </DNDTreeContext.Provider>\n  )\n}\n\ntype Story = StoryObj<typeof DNDTree>\n\nexport const Default: Story = {\n  render: () => <DNDTreeStory />,\n}\n\nconst meta: Meta<typeof DNDTree> = {\n  title: 'Components/DNDTree/DNDTree',\n  component: DNDTree,\n  decorators: [\n    (Story, context) => {\n      document.body.classList[context.globals?.darkMode ? 'add' : 'remove']('dark') // applies dark mode to everything inside body, e.g. portals, dialogs, etc.\n      return <Story />\n    },\n  ],\n} as Meta<typeof DNDTree>\n\nexport default meta\n",
      "type": "registry:ui",
      "target": "components/ui/dnd/dnd-tree.stories.tsx"
    },
    {
      "path": "src/components/ui/dnd/dnd-tree-items.tsx",
      "content": "import React from 'react'\nimport { TreeItem } from 'context/DNDTreeContext'\nimport { useDNDTree } from 'hooks/useDNDTree'\nimport { cn } from 'lib/utils'\nimport { ChevronDown, ChevronUp, Pencil, Trash2 } from 'lucide-react'\nimport { Button } from '../button'\nimport { LAST_DROPZONE_ID } from '../constants'\nimport { DNDDeleteItemDialog } from './dnd-delete-item-dialog'\nimport { Draggable, DroppableLine } from './dnd-drag-and-drop'\nimport { DNDItemDialog } from './dnd-item-dialog'\nimport { findItemById, findNestedLevel, getNestedLevelCount } from './utils/dnd'\nimport { createTreeItem, deleteTreeItem, updateTreeItem } from './utils/dnd-tree-items'\n\nconst MAX_ITEM_NESTED_LEVEL = 3\nconst ITEM_ROOT_LEVEL = 1\nconst ADD_SUB_ITEM = 'Add sub item'\n\ntype ItemToCreateProps = {\n  level: number\n  parentId: string | null\n}\n\ntype ItemToUpdateProps = {\n  id: string\n  name: string\n  level: number\n}\n\ntype ItemToDeleteProps = {\n  id: string\n  name: string\n  level: number\n}\n\ntype RenderItemProps = {\n  item: TreeItem\n  level: number\n}\n\ninterface DNDItemTreeProps {\n  draggedItemId?: string\n}\n\nexport const DNDTreeItems = ({ draggedItemId }: DNDItemTreeProps) => {\n  const [collapsedIds, setCollapsedIds] = React.useState<string[]>([])\n  const [hoveredId, setHoveredId] = React.useState<string | null>(null)\n  const { treeItems, setTreeItems } = useDNDTree()\n\n  const [itemToCreate, setItemToCreate] = React.useState<ItemToCreateProps | null>(null)\n  const [itemToUpdate, setItemToUpdate] = React.useState<ItemToUpdateProps | null>(null)\n  const [itemToDelete, setItemToDelete] = React.useState<ItemToDeleteProps | null>(null)\n\n  const isDragging = Boolean(draggedItemId)\n  const topLevelIds = treeItems.map(({ id }) => id)\n  const isActiveItemOnTopLevel = topLevelIds.includes(draggedItemId ?? '') && isDragging\n\n  const handleCollapse = (groupId: string) => {\n    setCollapsedIds((prevIds) =>\n      prevIds.includes(groupId) ? prevIds.filter((id) => id !== groupId) : [...prevIds, groupId],\n    )\n  }\n\n  const draggedItem = draggedItemId ? findItemById({ items: treeItems, id: draggedItemId }) : null\n  const draggedItemLevel = getNestedLevelCount({ item: draggedItem })\n\n  const renderItem = ({ item: { id, name, children }, level }: RenderItemProps) => {\n    const isRootLevel = level === ITEM_ROOT_LEVEL\n\n    const overItemNestedLevel = findNestedLevel({ items: treeItems, itemId: id })\n    const nestedLevels = draggedItemLevel + overItemNestedLevel\n\n    return (\n      <div className=\"my-[-1px]\" key={id}>\n        {!isRootLevel &&\n          isDragging &&\n          !isActiveItemOnTopLevel &&\n          nestedLevels < MAX_ITEM_NESTED_LEVEL && <DroppableLine id={id} />}\n        <div onMouseEnter={() => setHoveredId(id)}>\n          <Draggable\n            id={id}\n            isDraggable={!isRootLevel}\n            className={cn(isRootLevel && 'border-l-0 py-3 pl-4')}\n            name={name}\n            isDroppableEnabled={nestedLevels < MAX_ITEM_NESTED_LEVEL - 1}\n          >\n            {!isRootLevel && hoveredId === id && (\n              <>\n                <Button\n                  onClick={() => setItemToDelete({ id, level, name })}\n                  size=\"xs\"\n                  variant=\"unstyled\"\n                  className=\"p-2 text-destructive\"\n                >\n                  <Trash2 size={16} />\n                </Button>\n                <Button\n                  onClick={() => setItemToUpdate({ id, level, name })}\n                  size=\"xs\"\n                  variant=\"unstyled\"\n                  className=\"p-2 text-foreground\"\n                >\n                  <Pencil size={16} />\n                </Button>\n              </>\n            )}\n            {level < MAX_ITEM_NESTED_LEVEL && (\n              <>\n                <Button\n                  onClick={() => setItemToCreate({ level: level + 1, parentId: id })}\n                  variant=\"ghost\"\n                  size=\"sm\"\n                  className=\"text-foreground\"\n                >\n                  {ADD_SUB_ITEM}\n                </Button>\n                <div className=\"w-9\">\n                  {(children?.length ?? 0) > 0 && (\n                    <Button\n                      size=\"sm\"\n                      variant=\"unstyled\"\n                      className=\"p-2 text-foreground\"\n                      onClick={() => handleCollapse(id)}\n                    >\n                      {collapsedIds.includes(id) ? <ChevronDown /> : <ChevronUp />}\n                    </Button>\n                  )}\n                </div>\n              </>\n            )}\n          </Draggable>\n        </div>\n        {!collapsedIds.includes(id) && draggedItemId !== id && (\n          <div className=\"ml-3\">\n            {children?.map((child) => renderItem({ item: child, level: level + 1 }))}\n            {children?.[children.length - 1]?.id &&\n              isDragging &&\n              !isActiveItemOnTopLevel &&\n              nestedLevels < MAX_ITEM_NESTED_LEVEL - 1 && (\n                <DroppableLine id={`${LAST_DROPZONE_ID}${children[children.length - 1].id}`} />\n              )}\n          </div>\n        )}\n      </div>\n    )\n  }\n\n  return (\n    <div onMouseLeave={() => setHoveredId(null)}>\n      {treeItems.map((item) => (\n        <div key={item.id} className=\"mb-6 overflow-hidden rounded-lg border\">\n          {renderItem({ item, level: ITEM_ROOT_LEVEL })}\n        </div>\n      ))}\n      {itemToCreate && (\n        <DNDItemDialog\n          isOpen\n          title=\"Create tree item\"\n          onClose={() => setItemToCreate(null)}\n          onSubmit={({ name }) => {\n            if (itemToCreate.parentId) {\n              const updatedItems = createTreeItem({\n                name,\n                parentId: itemToCreate.parentId,\n                items: treeItems,\n              })\n              setTreeItems(updatedItems)\n              setItemToCreate(null)\n            }\n          }}\n        />\n      )}\n      {itemToUpdate && (\n        <DNDItemDialog\n          isOpen\n          title=\"Update tree item\"\n          onClose={() => setItemToUpdate(null)}\n          defaultValues={{ name: itemToUpdate.name }}\n          onSubmit={({ name }) => {\n            if (itemToUpdate.id) {\n              const updatedItems = updateTreeItem({\n                name,\n                itemId: itemToUpdate.id,\n                items: treeItems,\n              })\n              setTreeItems(updatedItems)\n              setItemToUpdate(null)\n            }\n          }}\n        />\n      )}\n      {itemToDelete && (\n        <DNDDeleteItemDialog\n          isOpen\n          itemToDelete={itemToDelete}\n          onClose={() => setItemToDelete(null)}\n          onSubmit={() => {\n            if (itemToDelete.id) {\n              deleteTreeItem(treeItems, itemToDelete.id)\n              setItemToDelete(null)\n            }\n          }}\n        />\n      )}\n    </div>\n  )\n}\n",
      "type": "registry:ui",
      "target": "components/ui/dnd/dnd-tree-items.tsx"
    },
    {
      "path": "src/components/ui/dnd/dnd-drag-and-drop.tsx",
      "content": "import { DragOverlay, useDraggable, useDroppable } from '@dnd-kit/core'\nimport { cn } from 'lib/utils'\nimport { ArrowUpIcon, Equal } from 'lucide-react'\nimport { Button } from '../button'\nimport { TREE_ITEM_DROPZONE_ID } from '../constants'\n\ntype DroppableProps = {\n  id: string\n  className?: string\n}\n\nexport const DroppableLine = ({ id, className }: DroppableProps) => {\n  const { isOver, setNodeRef } = useDroppable({ id })\n\n  return (\n    <div ref={setNodeRef} className={cn('relative min-h-1', isOver && 'bg-primary-600', className)}>\n      {isOver && <ArrowUpIcon className=\"absolute left-[-10px] top-[-5px] text-foreground\" />}\n    </div>\n  )\n}\n\ntype DraggableOverlayProps = {\n  name: string\n  icon?: React.ReactElement\n}\n\nexport const DraggableOverlay = ({ name, icon }: DraggableOverlayProps) => (\n  <DragOverlay className=\"min-w-full cursor-grab\">\n    <div className=\"flex items-center gap-1.5 rounded-lg border px-4 py-1\">\n      <Button className=\"cursor-grab p-2\" size=\"xs\" variant=\"unstyled\">\n        <Equal size={16} />\n      </Button>\n      {icon}\n      <p className=\"text-sm\">{name}</p>\n    </div>\n  </DragOverlay>\n)\n\ntype DraggableProps = {\n  id: string\n  name: string\n  className?: string\n  children?: React.ReactNode\n  isDraggable?: boolean\n  isDroppableEnabled?: boolean\n}\n\nexport const Draggable = ({\n  id,\n  className,\n  children,\n  name,\n  isDraggable = true,\n  isDroppableEnabled = false,\n}: DraggableProps) => {\n  const { attributes, listeners, setNodeRef, active } = useDraggable({\n    id,\n    data: { name },\n  })\n  const {\n    setNodeRef: setDroppableRef,\n    isOver: isDroppableOver,\n    active: droppableActive,\n  } = useDroppable({ id: `${TREE_ITEM_DROPZONE_ID}${id}`, disabled: !isDroppableEnabled })\n\n  return (\n    <div\n      className={cn(\n        'py-2 px-3 pr-1.5 border border-secondary-200 border-r-0 bg-background',\n        active?.id === id && 'opacity-50',\n        droppableActive?.id !== id && isDroppableOver && 'bg-primary-300 ',\n        className,\n      )}\n    >\n      <div className=\"relative flex items-center gap-1.5\">\n        <div ref={setDroppableRef} className=\"pointer-events-none absolute h-[1px] w-full\" />\n        {isDraggable && (\n          <Button\n            ref={setNodeRef}\n            size=\"xs\"\n            variant=\"unstyled\"\n            className=\"cursor-grab p-2\"\n            {...listeners}\n            {...attributes}\n          >\n            <Equal size={16} />\n          </Button>\n        )}\n        <p className=\"ml-0.5 text-sm text-foreground\">{name}</p>\n        <div className=\"ml-auto flex items-center\">{children}</div>\n      </div>\n    </div>\n  )\n}\n",
      "type": "registry:ui",
      "target": "components/ui/dnd/dnd-drag-and-drop.tsx"
    },
    {
      "path": "src/components/ui/dnd/dnd-item-dialog.tsx",
      "content": "import { useForm } from 'react-hook-form'\nimport { zodResolver } from '@hookform/resolvers/zod'\nimport { z } from 'zod'\nimport { Button } from '../button'\nimport { Dialog, DialogContent, DialogFooter, DialogHeader, DialogTitle } from '../dialog'\nimport { Form, FormControl, FormField, FormItem, FormLabel } from '../form'\nimport { Input } from '../input'\n\nconst NAME_LABEL = 'Name'\nconst CANCEL = 'Cancel'\n\nconst formSchema = z.object({\n  name: z.string().min(1).max(128),\n})\n\ntype DNDItemDialogrops = {\n  isOpen: boolean\n  onClose: () => void\n  title: string\n  onSubmit: ({ name }: { name: string }) => void\n  defaultValues?: {\n    name: string\n  }\n}\n\nexport const DNDItemDialog = ({\n  title,\n  isOpen,\n  onClose,\n  defaultValues,\n  onSubmit,\n}: DNDItemDialogrops) => {\n  const isUpdatingItem = Boolean(defaultValues)\n\n  const formMethods = useForm<z.infer<typeof formSchema>>({\n    resolver: zodResolver(formSchema),\n    shouldUnregister: true,\n    defaultValues: {\n      name: defaultValues?.name ?? '',\n    },\n  })\n  const { handleSubmit, formState } = formMethods\n\n  return (\n    <Dialog open={isOpen} onOpenChange={onClose}>\n      <DialogContent className=\"min-w-[35rem]\">\n        <Form {...formMethods}>\n          {/* eslint-disable-next-line @typescript-eslint/no-misused-promises */}\n          <form onSubmit={handleSubmit(({ name }) => onSubmit({ name }))}>\n            <DialogHeader>\n              <DialogTitle>{title}</DialogTitle>\n            </DialogHeader>\n            <div className=\"mt-4 flex flex-col gap-1\">\n              <FormField\n                required\n                name=\"name\"\n                control={formMethods.control}\n                render={({ field }) => (\n                  <FormItem>\n                    <FormLabel>{NAME_LABEL}</FormLabel>\n                    <FormControl>\n                      <Input {...field} placeholder=\"Enter name of item\" />\n                    </FormControl>\n                  </FormItem>\n                )}\n              />\n            </div>\n            <DialogFooter className=\"ml-auto mt-4 flex gap-2\">\n              <Button variant=\"secondary\" onClick={onClose}>\n                {CANCEL}\n              </Button>\n              <Button\n                type=\"submit\"\n                isLoading={formState.isSubmitting}\n                disabled={!formState.isDirty}\n              >\n                {isUpdatingItem ? 'Update' : 'Add'}\n              </Button>\n            </DialogFooter>\n          </form>\n        </Form>\n      </DialogContent>\n    </Dialog>\n  )\n}\n",
      "type": "registry:ui",
      "target": "components/ui/dnd/dnd-item-dialog.tsx"
    },
    {
      "path": "src/components/ui/dnd/dnd-delete-item-dialog.tsx",
      "content": "import { TreeItem } from 'context/DNDTreeContext'\nimport { Button } from '../button'\nimport { Dialog, DialogContent, DialogFooter, DialogHeader, DialogTitle } from '../dialog'\n\ninterface DNDDeleteItemDialogProps {\n  isOpen: boolean\n  onClose: () => void\n  onSubmit: () => void\n  itemToDelete: TreeItem\n}\n\nexport const DNDDeleteItemDialog = ({\n  isOpen,\n  onClose,\n  onSubmit,\n  itemToDelete,\n}: DNDDeleteItemDialogProps) => (\n  <Dialog open={isOpen} onOpenChange={onClose}>\n    <DialogContent>\n      <DialogHeader>\n        <DialogTitle>Delete item</DialogTitle>\n      </DialogHeader>\n      <div className=\"mt-4\">\n        <p>\n          Do you really want to delete item <span className=\"font-medium\">{itemToDelete.name}</span>\n          ?\n        </p>\n      </div>\n      <DialogFooter className=\"mt-4\">\n        <Button onClick={onClose} variant=\"secondary\">\n          Cancel\n        </Button>\n        <Button\n          onClick={onSubmit}\n          className=\"bg-destructive text-destructive-foreground hover:bg-destructive\"\n        >\n          Delete\n        </Button>\n      </DialogFooter>\n    </DialogContent>\n  </Dialog>\n)\n",
      "type": "registry:ui",
      "target": "components/ui/dnd/dnd-delete-item-dialog.tsx"
    },
    {
      "path": "src/components/ui/dnd/utils/dnd.ts",
      "content": "import { TreeItem } from 'context/DNDTreeContext'\nimport { LAST_DROPZONE_ID, TREE_ITEM_DROPZONE_ID } from '../../constants'\n\ntype FindItemByIdProps<T> = {\n  items: T[]\n  id: string\n}\n\nexport const findItemById = <T extends TreeItem>({ items, id }: FindItemByIdProps<T>): T | null => {\n  let result = null\n\n  items.forEach((item) => {\n    if (item.id === id) {\n      result = item\n    } else if (item.children) {\n      const found = findItemById({ items: item.children, id })\n      if (found) {\n        result = found\n      }\n    }\n  })\n\n  return result\n}\n\ntype FindNestedLevelProps = {\n  items: TreeItem[]\n  itemId: string\n  currentLevel?: number\n}\n\nexport function findNestedLevel({ items, itemId, currentLevel = 0 }: FindNestedLevelProps) {\n  let result = -1\n\n  items.forEach((item) => {\n    if (item.id === itemId) {\n      result = currentLevel\n    } else if (item.children) {\n      const nestedLevel = findNestedLevel({\n        items: item.children,\n        itemId,\n        currentLevel: currentLevel + 1,\n      })\n      if (nestedLevel !== -1) {\n        result = nestedLevel\n      }\n    }\n  })\n\n  return result\n}\n\ntype CountNestedLevelsProps = {\n  item: TreeItem | null\n  currentLevel?: number\n}\n\nexport const getNestedLevelCount = ({ item, currentLevel = 0 }: CountNestedLevelsProps) => {\n  if (!item?.children || item.children.length === 0) {\n    return currentLevel\n  }\n\n  let maxNestedLevels = currentLevel\n\n  item.children.forEach((child) => {\n    const nestedLevels = getNestedLevelCount({ item: child, currentLevel: currentLevel + 1 })\n    maxNestedLevels = Math.max(maxNestedLevels, nestedLevels)\n  })\n\n  return maxNestedLevels\n}\n\ntype RecursiveRemoveItemByIdProps<T> = {\n  items: T[]\n  id: string\n}\n\nexport const recursiveRemoveItemById = <T extends TreeItem>({\n  items,\n  id,\n}: RecursiveRemoveItemByIdProps<T>) =>\n  items.reduce((acc, item) => {\n    if (item.id === id) {\n      return acc\n    }\n    const newItem = { ...item }\n    if (newItem.children) {\n      newItem.children = recursiveRemoveItemById({ items: newItem.children, id })\n    }\n    acc.push(newItem)\n    return acc\n  }, [] as T[])\n\ntype MoveItemProps<T extends TreeItem> = {\n  dropzoneId: string\n  id: string\n  onMove: (items: T[]) => void\n  items: T[]\n}\n\ntype MoveItemReturnType = {\n  parentId?: string\n  beforeId?: string | null\n}\n\nconst getOverId = (dropzoneId: string) => {\n  if (dropzoneId?.includes(LAST_DROPZONE_ID)) {\n    return dropzoneId.split(LAST_DROPZONE_ID)[1]\n  }\n  if (dropzoneId?.includes(TREE_ITEM_DROPZONE_ID)) {\n    return dropzoneId.split(TREE_ITEM_DROPZONE_ID)[1]\n  }\n  return dropzoneId\n}\n\ntype FindParentIdProps = {\n  items: TreeItem[]\n  itemId: string\n  parentId?: string | null\n}\n\nexport const findParentId = ({ items, itemId, parentId = null }: FindParentIdProps) => {\n  if (!itemId) {\n    return null\n  }\n\n  let result: string | null = null\n\n  items.forEach((item) => {\n    if (item.id === itemId) {\n      result = parentId\n    } else if (item.children) {\n      result = result || findParentId({ items: item.children, itemId, parentId: item.id })\n    }\n  })\n\n  return result\n}\n\nexport const moveItem = <T extends TreeItem>({\n  dropzoneId,\n  id,\n  onMove,\n  items,\n}: MoveItemProps<T>): MoveItemReturnType => {\n  if (id === dropzoneId) {\n    return {}\n  }\n\n  const overId = getOverId(dropzoneId)\n\n  if (overId === id) {\n    return {}\n  }\n\n  const parentId = findParentId({ items, itemId: overId })\n  const itemToMove = findItemById({ items, id })\n\n  if (!itemToMove) {\n    return {}\n  }\n\n  const updatedItems = recursiveRemoveItemById({ items, id })\n\n  if (dropzoneId.includes(TREE_ITEM_DROPZONE_ID)) {\n    const parent = findItemById({ items: updatedItems, id: overId })\n\n    if (parent) {\n      parent.children = [...(parent?.children || []), itemToMove]\n    }\n\n    onMove(updatedItems)\n\n    return { parentId: overId, beforeId: null }\n  }\n\n  if (!parentId) {\n    if (dropzoneId === LAST_DROPZONE_ID) {\n      onMove([...updatedItems, itemToMove])\n      return { beforeId: null }\n    }\n    const index = updatedItems.findIndex((item) => item.id === overId)\n    updatedItems.splice(index, 0, itemToMove)\n\n    onMove(updatedItems)\n    return { beforeId: overId }\n  }\n\n  const parent = findItemById({ items: updatedItems, id: parentId })\n\n  if (parent) {\n    if (dropzoneId.includes(LAST_DROPZONE_ID)) {\n      parent.children = [...(parent?.children || []), itemToMove]\n      onMove(updatedItems)\n\n      return { parentId, beforeId: null }\n    }\n    parent.children = parent.children || []\n\n    const index = parent.children.findIndex((item) => item.id === overId)\n    parent.children.splice(index, 0, itemToMove)\n\n    onMove(updatedItems)\n\n    return { parentId, beforeId: overId }\n  }\n  return {}\n}\n",
      "type": "registry:ui",
      "target": "components/ui/dnd/utils/dnd.ts"
    },
    {
      "path": "src/components/ui/dnd/utils/dnd-tree.ts",
      "content": "import { TreeItem } from 'context/DNDTreeContext'\n\nconst findAndRemoveItem = (\n  currentItems: TreeItem[],\n  currentItemId: string,\n): { item: TreeItem | null; remainingItems: TreeItem[] } => {\n  for (let i = 0; i < currentItems.length; i += 1) {\n    const item = currentItems[i]\n    if (item.id === currentItemId) {\n      const remainingItems = [...currentItems.slice(0, i), ...currentItems.slice(i + 1)]\n      return { item, remainingItems }\n    }\n    if (item.children) {\n      const { item: found, remainingItems } = findAndRemoveItem(item.children, currentItemId)\n      if (found) {\n        item.children = remainingItems\n        return { item: found, remainingItems: currentItems }\n      }\n    }\n  }\n  return { item: null, remainingItems: currentItems }\n}\n\nconst insertItem = (\n  currentItems: TreeItem[],\n  currentItem: TreeItem,\n  currentBeforeId: string | null,\n): TreeItem[] => {\n  if (currentBeforeId === null) {\n    return [...currentItems, currentItem]\n  }\n  const index = currentItems.findIndex((i) => i.id === currentBeforeId)\n  if (index === -1) {\n    return [...currentItems, currentItem]\n  }\n  return [...currentItems.slice(0, index), currentItem, ...currentItems.slice(index)]\n}\n\nconst findParent = (currentItems: TreeItem[], currentParentId: string): TreeItem | null => {\n  // eslint-disable-next-line no-restricted-syntax\n  for (const currentItem of currentItems) {\n    if (currentItem.id === currentParentId) {\n      return currentItem\n    }\n    if (currentItem.children) {\n      const found = findParent(currentItem.children, currentParentId)\n      if (found) {\n        return found\n      }\n    }\n  }\n  return null\n}\n\nexport const updateItems = ({\n  beforeId,\n  itemId,\n  items,\n  parentId,\n}: {\n  items: TreeItem[]\n  itemId: string\n  parentId: string | null\n  beforeId: string | null\n}): TreeItem[] => {\n  const { item, remainingItems } = findAndRemoveItem(items, itemId)\n  if (!item) {\n    throw new Error(`Item with id ${itemId} not found`)\n  }\n\n  if (parentId === null) {\n    return insertItem(remainingItems, item, beforeId)\n  }\n\n  const parent = findParent(remainingItems, parentId)\n  if (!parent) {\n    throw new Error(`Parent with id ${parentId} not found`)\n  }\n\n  if (!parent.children) {\n    parent.children = []\n  }\n\n  parent.children = insertItem(parent.children, item, beforeId)\n\n  const updateParent = (currentItems: TreeItem[]): TreeItem[] =>\n    currentItems.map((currentItem) => {\n      if (currentItem.id === parentId) {\n        return { ...currentItem, children: parent.children }\n      }\n      if (currentItem.children) {\n        return { ...currentItem, children: updateParent(currentItem.children) }\n      }\n      return currentItem\n    })\n  return updateParent(remainingItems)\n}\n",
      "type": "registry:ui",
      "target": "components/ui/dnd/utils/dnd-tree.ts"
    },
    {
      "path": "src/components/ui/dnd/utils/dnd-tree-items.ts",
      "content": "import { TreeItem } from 'context/DNDTreeContext'\n\nconst findParent = (currentItems: TreeItem[], currentParentId: string): TreeItem | null => {\n  // eslint-disable-next-line no-restricted-syntax\n  for (const item of currentItems) {\n    if (item.id === currentParentId) {\n      return item\n    }\n    if (item.children) {\n      const found = findParent(item.children, currentParentId)\n      if (found) {\n        return found\n      }\n    }\n  }\n  return null\n}\n\nexport const createTreeItem = ({\n  items,\n  name,\n  parentId,\n}: {\n  items: TreeItem[]\n  name: string\n  parentId: string\n}): TreeItem[] => {\n  const newItem: TreeItem = { id: `${Date.now()}`, name }\n\n  if (parentId === null) {\n    return [...items, newItem]\n  }\n\n  const parent = findParent(items, parentId)\n  if (!parent) {\n    throw new Error(`Parent with id ${parentId} not found`)\n  }\n\n  if (!parent.children) {\n    parent.children = []\n  }\n\n  parent.children.push(newItem)\n  return items\n}\n\nconst updateItem = (currentItems: TreeItem[], itemId: string, name: string): boolean => {\n  // eslint-disable-next-line no-restricted-syntax\n  for (const item of currentItems) {\n    if (item.id === itemId) {\n      item.name = name\n      return true\n    }\n    if (item.children) {\n      if (updateItem(item.children, itemId, name)) {\n        return true\n      }\n    }\n  }\n  return false\n}\n\nexport const updateTreeItem = ({\n  itemId,\n  items,\n  name,\n}: {\n  items: TreeItem[]\n  itemId: string\n  name: string\n}): TreeItem[] => {\n  if (!updateItem(items, itemId, name)) {\n    throw new Error(`Item with id ${itemId} not found`)\n  }\n\n  return items\n}\n\nexport const deleteTreeItem = (currentItems: TreeItem[], itemId: string): TreeItem[] =>\n  currentItems.reduce((acc, item) => {\n    if (item.id === itemId) {\n      return acc\n    }\n    if (item.children) {\n      // eslint-disable-next-line no-param-reassign\n      item.children = deleteTreeItem(item.children, itemId)\n    }\n    return [...acc, item]\n  }, [] as TreeItem[])\n",
      "type": "registry:ui",
      "target": "components/ui/dnd/utils/dnd-tree-items.ts"
    },
    {
      "path": "src/components/ui/constants.ts",
      "content": "export const TREE_ITEM_DROPZONE_ID = 'tree-item'\nexport const LAST_DROPZONE_ID = 'last'\n",
      "type": "registry:ui",
      "target": "components/ui/constants.ts"
    }
  ],
  "docs": "Use the DND Tree component to create interactive tree structures with drag and drop functionality",
  "categories": [
    "UI",
    "Interaction"
  ]
}